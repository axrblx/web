<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistema de Partículas 3D</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; 
            background-color: #000000; 
            color: white; 
            font-family: 'Courier New', monospace; 
        }
        canvas {
            display: block; 
            width: 100%; 
            height: 100%; 
        }
        #interfaz-usuario {
            position: absolute;
            top: 15px; 
            width: 100%;
            text-align: center;
            z-index: 100; 
            pointer-events: none; 
        }
        #info {
            font-size: 14px;
            padding: 10px 18px; 
            background-color: rgba(25, 30, 50, 0.35); 
            border-radius: 10px; 
            display: inline-block;
            text-shadow: 0 0 5px rgba(0, 128, 255, 0.8); 
            border: 1px solid rgba(255, 255, 255, 0.1); 
            backdrop-filter: blur(10px); 
            -webkit-backdrop-filter: blur(10px); 
            transition: all 0.3s ease; 
            box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.05); 
        }
        #cargando {
            position: fixed;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column; 
            justify-content: center;
            align-items: center;
            z-index: 1000; 
            transition: opacity 0.6s ease-out; 
        }
        #cargando span {
            font-size: 24px;
            letter-spacing: 2px;
            margin-bottom: 15px; 
        }
        #contenedor-progreso {
             width: 60%;
             max-width: 300px;
             height: 6px;
             background-color: rgba(255, 255, 255, 0.1);
             border-radius: 3px;
             overflow: hidden; 
        }
        #barra-progreso {
            height: 100%;
            width: 0%; 
            background: linear-gradient(90deg, #00a2ff, #00ffea); 
            transition: width 0.3s ease; 
            border-radius: 3px;
        }
        #controles {
            position: absolute;
            bottom: 20px; 
            left: 50%;
            transform: translateX(-50%); 
            z-index: 100;
            text-align: center;
            pointer-events: all; 
            background-color: rgba(25, 30, 50, 0.4); 
            padding: 15px 25px; 
            border-radius: 12px; 
            border: 1px solid rgba(255, 255, 255, 0.12); 
            backdrop-filter: blur(12px); 
             -webkit-backdrop-filter: blur(12px); 
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); 
        }
        button {
            background: rgba(0, 80, 180, 0.7); 
            color: white;
            border: 1px solid rgba(0, 180, 255, 0.6); 
            border-radius: 6px;
            padding: 8px 15px;
            margin: 0 8px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            transition: all 0.25s ease;
        }
        button:hover {
            background: rgba(0, 110, 220, 0.9); 
            border-color: rgba(0, 210, 255, 0.9);
            transform: translateY(-1px);
            box-shadow: 0 3px 8px rgba(0, 150, 255, 0.3);
        }
        #selector-color {
            margin-top: 15px; 
            display: flex;
            justify-content: center;
            gap: 12px;
        }
        .opcion-color {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.2); 
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: inset 0 0 4px rgba(0,0,0,0.4); 
        }
        .opcion-color:hover {
            transform: scale(1.15);
            border-color: rgba(255, 255, 255, 0.7); 
        }
         .opcion-color.activo {
             transform: scale(1.18);
             border-color: white;
             box-shadow: 0 0 10px rgba(255, 255, 255, 0.7); 
         }
    </style>
</head>
<body>
    <div id="cargando">
        <span>Inicializando partículas...</span>
        <div id="contenedor-progreso">
             <div id="barra-progreso"></div>
        </div>
    </div>

    <div id="interfaz-usuario">
        <div id="info">Forma (Haga clic para transformarse)</div>
    </div>

    <div id="controles">
        <button id="boton-forma">Cambiar forma</button>

        <div id="selector-color">
            <div class="opcion-color" data-esquema="fuego" style="background: linear-gradient(to bottom right, #ff4500, #ffcc00)"></div>
            <div class="opcion-color" data-esquema="neon" style="background: linear-gradient(to bottom right, #ff00ff, #00ffff)"></div>
            <div class="opcion-color" data-esquema="naturaleza" style="background: linear-gradient(to bottom right, #00ff00, #66ffcc)"></div>
            <div class="opcion-color" data-esquema="arcoiris" style="background: linear-gradient(to right, red, orange, yellow, green, blue, indigo, violet)"></div>
        </div>
    </div>

    <canvas id="lienzo-webgl"></canvas>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/",
          "animejs": "https://cdn.jsdelivr.net/npm/animejs@3.2.2/lib/anime.es.js",
          "simplex-noise": "https://cdn.skypack.dev/simplex-noise@4.0.1"
        }
      }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import anime from 'animejs';
        import { createNoise3D, createNoise4D } from 'simplex-noise';

        // Variables globales
        let escena, camara, renderizador, controles, reloj;
        let compositor, pasoBloom; 
        let geometriaParticulas, materialParticulas, sistemaParticulas;
        let posicionesActuales, posicionesOrigen, posicionesObjetivo, posicionesEnjambre; 
        let tamanosParticulas, opacidadesParticulas, intensidadesEfectoParticulas; 
        let ruido3D, ruido4D; 
        let lineaTiempoMorph = null; 
        let estaInicializado = false;
        let estaMorphing = false;

        // Configuración
        const CONFIG = {
            cantidadParticulas: 15000,
            tamanoForma: 14,
            factorDistanciaEnjambre: 1.5,
            factorRemolino: 4.0,
            frecuenciaRuido: 0.1,
            escalaTiempoRuido: 0.04,
            intensidadMaximaRuido: 2.8,
            esquemaColor: 'fuego',
            duracionMorph: 4000,
            rangoTamanoParticula: [0.08, 0.25],
            cantidadEstrellas: 18000,
            intensidadBloom: 1.3,
            radioBloom: 0.5,
            umbralBloom: 0.05,
            intensidadFlujoInactivo: 0.25,
            velocidadFlujoInactivo: 0.08,
            velocidadRotacionInactiva: 0.02,
            factorTamanoMorph: 0.5, 
            factorBrilloMorph: 0.6 
        };

        // Definición de formas
        const FORMAS = [
            { nombre: 'Esfera', generador: generarEsfera },
            { nombre: 'Cubo', generador: generarCubo },
            { nombre: 'Pirámide', generador: generarPiramide },
            { nombre: 'Toro', generador: generarToro },
            { nombre: 'Galaxia', generador: generarGalaxia },
            { nombre: 'Ola', generador: generarOnda }
        ];
        let indiceFormaActual = 0;

        // Estado de morphing
        const estadoMorph = { progreso: 0.0 };

        // Esquemas de color
        const ESQUEMAS_COLOR = {
            fuego: { tonoInicio: 0, tonoFin: 45, saturacion: 0.95, luminosidad: 0.6 },
            neon: { tonoInicio: 300, tonoFin: 180, saturacion: 1.0, luminosidad: 0.65 },
            naturaleza: { tonoInicio: 90, tonoFin: 160, saturacion: 0.85, luminosidad: 0.55 },
            arcoiris: { tonoInicio: 0, tonoFin: 360, saturacion: 0.9, luminosidad: 0.6 }
        };

        // Vectores temporales para optimización
        const vecTemp = new THREE.Vector3();
        const vecOrigen = new THREE.Vector3();
        const vecObjetivo = new THREE.Vector3();
        const vecEnjambre = new THREE.Vector3();
        const desplazamientoRuido = new THREE.Vector3();
        const vecFlujo = new THREE.Vector3();
        const posBezier = new THREE.Vector3();
        const ejeRemolino = new THREE.Vector3();
        const vecActual = new THREE.Vector3();

        // Generadores de formas
        function generarEsfera(cantidad, tamano) {
            const puntos = new Float32Array(cantidad * 3);
            const phi = Math.PI * (Math.sqrt(5) - 1);
            for (let i = 0; i < cantidad; i++) {
                const y = 1 - (i / (cantidad - 1)) * 2;
                const radio = Math.sqrt(1 - y * y);
                const theta = phi * i;
                const x = Math.cos(theta) * radio;
                const z = Math.sin(theta) * radio;
                puntos[i * 3] = x * tamano;
                puntos[i * 3 + 1] = y * tamano;
                puntos[i * 3 + 2] = z * tamano;
            }
            return puntos;
        }

        function generarCubo(cantidad, tamano) {
            const puntos = new Float32Array(cantidad * 3);
            const mitadTamano = tamano / 2;
            for (let i = 0; i < cantidad; i++) {
                const cara = Math.floor(Math.random() * 6);
                const u = Math.random() * tamano - mitadTamano;
                const v = Math.random() * tamano - mitadTamano;
                switch (cara) {
                    case 0: puntos.set([mitadTamano, u, v], i * 3); break;
                    case 1: puntos.set([-mitadTamano, u, v], i * 3); break;
                    case 2: puntos.set([u, mitadTamano, v], i * 3); break;
                    case 3: puntos.set([u, -mitadTamano, v], i * 3); break;
                    case 4: puntos.set([u, v, mitadTamano], i * 3); break;
                    case 5: puntos.set([u, v, -mitadTamano], i * 3); break;
                }
            }
            return puntos;
        }

        function generarPiramide(cantidad, tamano) {
            const puntos = new Float32Array(cantidad * 3);
            const mitadBase = tamano / 2;
            const altura = tamano * 1.2;
            const apice = new THREE.Vector3(0, altura / 2, 0);
            const verticesBase = [
                new THREE.Vector3(-mitadBase, -altura / 2, -mitadBase), 
                new THREE.Vector3(mitadBase, -altura / 2, -mitadBase),
                new THREE.Vector3(mitadBase, -altura / 2, mitadBase), 
                new THREE.Vector3(-mitadBase, -altura / 2, mitadBase)
            ];
            const areaBase = tamano * tamano;
            const alturaCaraLateral = Math.sqrt(Math.pow(altura, 2) + Math.pow(mitadBase, 2));
            const areaCaraLateral = 0.5 * tamano * alturaCaraLateral;
            const areaTotal = areaBase + 4 * areaCaraLateral;
            const pesoBase = areaBase / areaTotal;
            const pesoLado = areaCaraLateral / areaTotal;
            for (let i = 0; i < cantidad; i++) {
                const r = Math.random();
                let p = new THREE.Vector3(); 
                let u, v;
                if (r < pesoBase) {
                    u = Math.random(); 
                    v = Math.random();
                    p.lerpVectors(verticesBase[0], verticesBase[1], u);
                    const p2 = new THREE.Vector3().lerpVectors(verticesBase[3], verticesBase[2], u);
                    p.lerp(p2, v);
                } else {
                    const indiceCara = Math.floor((r - pesoBase) / pesoLado);
                    const v1 = verticesBase[indiceCara]; 
                    const v2 = verticesBase[(indiceCara + 1) % 4];
                    u = Math.random(); 
                    v = Math.random();
                    if (u + v > 1) { 
                        u = 1 - u; 
                        v = 1 - v; 
                    }
                    p.addVectors(v1, vecTemp.subVectors(v2, v1).multiplyScalar(u));
                    p.add(vecTemp.subVectors(apice, v1).multiplyScalar(v));
                }
                puntos.set([p.x, p.y, p.z], i * 3);
            }
            return puntos;
        }

        function generarToro(cantidad, tamano) {
            const puntos = new Float32Array(cantidad * 3);
            const R = tamano * 0.7; 
            const r = tamano * 0.3;
            for (let i = 0; i < cantidad; i++) {
                const theta = Math.random() * Math.PI * 2; 
                const phi = Math.random() * Math.PI * 2;
                const x = (R + r * Math.cos(phi)) * Math.cos(theta);
                const y = r * Math.sin(phi);
                const z = (R + r * Math.cos(phi)) * Math.sin(theta);
                puntos[i * 3] = x; 
                puntos[i * 3 + 1] = y; 
                puntos[i * 3 + 2] = z;
            }
            return puntos;
        }

        function generarGalaxia(cantidad, tamano) {
            const puntos = new Float32Array(cantidad * 3);
            const brazos = 4; 
            const anchoBrazo = 0.6; 
            const factorAbultamiento = 0.3;
            for (let i = 0; i < cantidad; i++) {
                const t = Math.pow(Math.random(), 1.5); 
                const radio = t * tamano;
                const indiceBrazo = Math.floor(Math.random() * brazos);
                const desplazamientoBrazo = (indiceBrazo / brazos) * Math.PI * 2;
                const cantidadRotacion = radio / tamano * 6; 
                const angulo = desplazamientoBrazo + cantidadRotacion;
                const dispersion = (Math.random() - 0.5) * anchoBrazo * (1 - radio / tamano);
                const theta = angulo + dispersion;
                const x = radio * Math.cos(theta); 
                const z = radio * Math.sin(theta);
                const y = (Math.random() - 0.5) * tamano * 0.1 * (1 - radio / tamano * factorAbultamiento);
                puntos[i * 3] = x; 
                puntos[i * 3 + 1] = y; 
                puntos[i * 3 + 2] = z;
            }
            return puntos;
        }

        function generarOnda(cantidad, tamano) {
            const puntos = new Float32Array(cantidad * 3);
            const escalaOnda = tamano * 0.4; 
            const frecuencia = 3;
            for (let i = 0; i < cantidad; i++) {
                const u = Math.random() * 2 - 1; 
                const v = Math.random() * 2 - 1;
                const x = u * tamano; 
                const z = v * tamano;
                const dist = Math.sqrt(u * u + v * v); 
                const angulo = Math.atan2(v, u);
                const y = Math.sin(dist * Math.PI * frecuencia) * Math.cos(angulo * 2) * escalaOnda * (1 - dist);
                puntos[i * 3] = x; 
                puntos[i * 3 + 1] = y; 
                puntos[i * 3 + 2] = z;
            }
            return puntos;
        }

        // Función de inicialización principal
        function inicializar() {
            let progreso = 0;
            const barraProgreso = document.getElementById('barra-progreso');
            const pantallaCarga = document.getElementById('cargando');
            
            function actualizarProgreso(incremento) {
                progreso += incremento;
                barraProgreso.style.width = `${Math.min(100, progreso)}%`;
                if (progreso >= 100) {
                    setTimeout(() => {
                        pantallaCarga.style.opacity = '0';
                        setTimeout(() => { pantallaCarga.style.display = 'none'; }, 600);
                    }, 200);
                }
            }

            reloj = new THREE.Clock();
            ruido3D = createNoise3D(() => Math.random());
            ruido4D = createNoise4D(() => Math.random());
            escena = new THREE.Scene();
            escena.fog = new THREE.FogExp2(0x000308, 0.03);
            actualizarProgreso(5);

            camara = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            camara.position.set(0, 8, 28); 
            camara.lookAt(escena.position);
            actualizarProgreso(5);

            const lienzo = document.getElementById('lienzo-webgl');
            renderizador = new THREE.WebGLRenderer({ 
                canvas: lienzo, 
                antialias: true, 
                alpha: true, 
                powerPreference: 'high-performance' 
            });
            renderizador.setSize(window.innerWidth, window.innerHeight);
            renderizador.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderizador.toneMapping = THREE.ACESFilmicToneMapping;
            renderizador.toneMappingExposure = 1.1;
            actualizarProgreso(10);

            controles = new OrbitControls(camara, renderizador.domElement);
            controles.enableDamping = true; 
            controles.dampingFactor = 0.05;
            controles.minDistance = 5; 
            controles.maxDistance = 80;
            controles.autoRotate = true; 
            controles.autoRotateSpeed = 0.3;
            actualizarProgreso(5);

            escena.add(new THREE.AmbientLight(0x404060));
            const luzDir1 = new THREE.DirectionalLight(0xffffff, 1.5);
            luzDir1.position.set(15, 20, 10); 
            escena.add(luzDir1);
            const luzDir2 = new THREE.DirectionalLight(0x88aaff, 0.9);
            luzDir2.position.set(-15, -10, -15); 
            escena.add(luzDir2);
            actualizarProgreso(10);

            configurarPostProcesamiento(); 
            actualizarProgreso(10);
            crearCampoEstelar(); 
            actualizarProgreso(15);
            configurarSistemaParticulas(); 
            actualizarProgreso(25);

            window.addEventListener('resize', manejarRedimensionamiento);
            window.addEventListener('click', manejarClicLienzo);
            document.getElementById('boton-forma').addEventListener('click', activarMorph);
            document.querySelectorAll('.opcion-color').forEach(opcion => {
                opcion.addEventListener('click', (e) => {
                    document.querySelectorAll('.opcion-color').forEach(o => o.classList.remove('activo'));
                    e.target.classList.add('activo');
                    CONFIG.esquemaColor = e.target.dataset.esquema;
                    actualizarColores();
                });
            });
            document.querySelector(`.opcion-color[data-esquema="${CONFIG.esquemaColor}"]`).classList.add('activo');
            actualizarProgreso(15);

            estaInicializado = true;
            animar();
            console.log("Inicialización completada.");
        }

        function configurarPostProcesamiento() {
            compositor = new EffectComposer(renderizador);
            compositor.addPass(new RenderPass(escena, camara));
            pasoBloom = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight), 
                CONFIG.intensidadBloom, 
                CONFIG.radioBloom, 
                CONFIG.umbralBloom
            );
            compositor.addPass(pasoBloom);
        }

        function crearCampoEstelar() {
            const verticesEstrellas = []; 
            const tamanosEstrellas = []; 
            const coloresEstrellas = [];
            const geometriaEstrellas = new THREE.BufferGeometry();
            
            for (let i = 0; i < CONFIG.cantidadEstrellas; i++) {
                vecTemp.set( 
                    THREE.MathUtils.randFloatSpread(400), 
                    THREE.MathUtils.randFloatSpread(400), 
                    THREE.MathUtils.randFloatSpread(400) 
                );
                if (vecTemp.length() < 100) vecTemp.setLength(100 + Math.random() * 300);
                verticesEstrellas.push(vecTemp.x, vecTemp.y, vecTemp.z);
                tamanosEstrellas.push(Math.random() * 0.15 + 0.05);
                const color = new THREE.Color();
                if (Math.random() < 0.1) { 
                    color.setHSL(Math.random(), 0.7, 0.65); 
                } else { 
                    color.setHSL(0.6, Math.random() * 0.1, 0.8 + Math.random() * 0.2); 
                }
                coloresEstrellas.push(color.r, color.g, color.b);
            }
            
            geometriaEstrellas.setAttribute('position', new THREE.Float32BufferAttribute(verticesEstrellas, 3));
            geometriaEstrellas.setAttribute('color', new THREE.Float32BufferAttribute(coloresEstrellas, 3));
            geometriaEstrellas.setAttribute('size', new THREE.Float32BufferAttribute(tamanosEstrellas, 1));
            
            const materialEstrellas = new THREE.ShaderMaterial({
                 uniforms: { 
                     texturaPunto: { value: crearTexturaEstrella() } 
                 },
                 vertexShader: `
                      attribute float size; 
                      varying vec3 vColor; 
                      varying float vSize;
                      void main() {
                           vColor = color; 
                           vSize = size; 
                           vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                           gl_PointSize = size * (400.0 / -mvPosition.z); 
                           gl_Position = projectionMatrix * mvPosition;
                      }`,
                 fragmentShader: `
                      uniform sampler2D texturaPunto; 
                      varying vec3 vColor; 
                      varying float vSize;
                      void main() {
                           float alpha = texture2D(texturaPunto, gl_PointCoord).a; 
                           if (alpha < 0.1) discard;
                           gl_FragColor = vec4(vColor, alpha * 0.9);
                      }`,
                 blending: THREE.AdditiveBlending, 
                 depthWrite: false, 
                 transparent: true, 
                 vertexColors: true
             });
             
            escena.add(new THREE.Points(geometriaEstrellas, materialEstrellas));
        }

        function crearTexturaEstrella() {
            const tamano = 64; 
            const lienzo = document.createElement('canvas');
            lienzo.width = tamano; 
            lienzo.height = tamano; 
            const contexto = lienzo.getContext('2d');
            const gradiente = contexto.createRadialGradient(
                tamano / 2, tamano / 2, 0, 
                tamano / 2, tamano / 2, tamano / 2
            );
            gradiente.addColorStop(0, 'rgba(255,255,255,1)'); 
            gradiente.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradiente.addColorStop(0.5, 'rgba(255,255,255,0.3)'); 
            gradiente.addColorStop(1, 'rgba(255,255,255,0)');
            contexto.fillStyle = gradiente; 
            contexto.fillRect(0, 0, tamano, tamano);
            return new THREE.CanvasTexture(lienzo);
        }

        function configurarSistemaParticulas() {
            posicionesObjetivo = FORMAS.map(forma => forma.generador(CONFIG.cantidadParticulas, CONFIG.tamanoForma));
            geometriaParticulas = new THREE.BufferGeometry();

            posicionesActuales = new Float32Array(posicionesObjetivo[0]);
            posicionesOrigen = new Float32Array(posicionesObjetivo[0]);
            posicionesEnjambre = new Float32Array(CONFIG.cantidadParticulas * 3);
            geometriaParticulas.setAttribute('position', new THREE.BufferAttribute(posicionesActuales, 3));

            tamanosParticulas = new Float32Array(CONFIG.cantidadParticulas);
            opacidadesParticulas = new Float32Array(CONFIG.cantidadParticulas);
            intensidadesEfectoParticulas = new Float32Array(CONFIG.cantidadParticulas);
            
            for (let i = 0; i < CONFIG.cantidadParticulas; i++) {
                tamanosParticulas[i] = THREE.MathUtils.randFloat(
                    CONFIG.rangoTamanoParticula[0], 
                    CONFIG.rangoTamanoParticula[1]
                );
                opacidadesParticulas[i] = 1.0;
                intensidadesEfectoParticulas[i] = 0.0;
            }
            
            geometriaParticulas.setAttribute('size', new THREE.BufferAttribute(tamanosParticulas, 1));
            geometriaParticulas.setAttribute('opacity', new THREE.BufferAttribute(opacidadesParticulas, 1));
            geometriaParticulas.setAttribute('aIntensidadEfecto', new THREE.BufferAttribute(intensidadesEfectoParticulas, 1));

            const colores = new Float32Array(CONFIG.cantidadParticulas * 3);
            actualizarArrayColores(colores, posicionesActuales);
            geometriaParticulas.setAttribute('color', new THREE.BufferAttribute(colores, 3));

            materialParticulas = new THREE.ShaderMaterial({
                 uniforms: {
                      texturaPunto: { value: crearTexturaEstrella() }
                 },
                 vertexShader: `
                      attribute float size;
                      attribute float opacity;
                      attribute float aIntensidadEfecto;
                      varying vec3 vColor;
                      varying float vOpacity;
                      varying float vIntensidadEfecto;

                      void main() {
                           vColor = color;
                           vOpacity = opacity;
                           vIntensidadEfecto = aIntensidadEfecto;

                           vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);

                           float escalaTamano = 1.0 - vIntensidadEfecto * ${CONFIG.factorTamanoMorph.toFixed(2)};
                           gl_PointSize = size * escalaTamano * (400.0 / -mvPosition.z);

                           gl_Position = projectionMatrix * mvPosition;
                      }
                 `,
                 fragmentShader: `
                      uniform sampler2D texturaPunto;
                      varying vec3 vColor;
                      varying float vOpacity;
                      varying float vIntensidadEfecto;

                      void main() {
                           float alpha = texture2D(texturaPunto, gl_PointCoord).a;
                           if (alpha < 0.05) discard;

                           vec3 colorFinal = vColor * (1.0 + vIntensidadEfecto * ${CONFIG.factorBrilloMorph.toFixed(2)});

                           gl_FragColor = vec4(colorFinal, alpha * vOpacity);
                      }
                 `,
                 blending: THREE.AdditiveBlending,
                 depthTest: true,
                 depthWrite: false,
                 transparent: true,
                 vertexColors: true
            });

            sistemaParticulas = new THREE.Points(geometriaParticulas, materialParticulas);
            escena.add(sistemaParticulas);
        }

        function actualizarArrayColores(colores, arrayPosiciones) {
            const esquemaColor = ESQUEMAS_COLOR[CONFIG.esquemaColor];
            const centro = new THREE.Vector3(0, 0, 0);
            const radioMaximo = CONFIG.tamanoForma * 1.1;
            
            for (let i = 0; i < CONFIG.cantidadParticulas; i++) {
                const i3 = i * 3;
                vecTemp.fromArray(arrayPosiciones, i3);
                const distancia = vecTemp.distanceTo(centro);
                let tono;
                
                if (CONFIG.esquemaColor === 'arcoiris') {
                    const xNormalizado = (vecTemp.x / radioMaximo + 1) / 2; 
                    const yNormalizado = (vecTemp.y / radioMaximo + 1) / 2; 
                    const zNormalizado = (vecTemp.z / radioMaximo + 1) / 2;
                    tono = (xNormalizado * 120 + yNormalizado * 120 + zNormalizado * 120) % 360;
                } else {
                    tono = THREE.MathUtils.mapLinear( 
                        distancia, 0, radioMaximo, 
                        esquemaColor.tonoInicio, esquemaColor.tonoFin 
                    );
                }
                
                const valorRuido = (ruido3D(vecTemp.x * 0.2, vecTemp.y * 0.2, vecTemp.z * 0.2) + 1) * 0.5;
                const saturacion = THREE.MathUtils.clamp(
                    esquemaColor.saturacion * (0.9 + valorRuido * 0.2), 0, 1
                );
                const luminosidad = THREE.MathUtils.clamp(
                    esquemaColor.luminosidad * (0.85 + valorRuido * 0.3), 0.1, 0.9
                );
                
                const color = new THREE.Color().setHSL(tono / 360, saturacion, luminosidad);
                color.toArray(colores, i3);
            }
        }

        function actualizarColores() {
            const colores = geometriaParticulas.attributes.color.array;
            actualizarArrayColores(colores, geometriaParticulas.attributes.position.array);
            geometriaParticulas.attributes.color.needsUpdate = true;
        }

        function activarMorph() {
            if (estaMorphing) return;
            
            estaMorphing = true; 
            controles.autoRotate = false; 
            console.log("Morphing activado...");
            
            document.getElementById('info').innerText = `Morphing...`;
            document.getElementById('info').style.textShadow = '0 0 8px rgba(255, 150, 50, 0.9)';
            
            posicionesOrigen.set(posicionesActuales);
            const siguienteIndiceForma = (indiceFormaActual + 1) % FORMAS.length;
            const siguientePosicionesObjetivo = posicionesObjetivo[siguienteIndiceForma];
            const cantidadDesplazamientoCentro = CONFIG.tamanoForma * CONFIG.factorDistanciaEnjambre;
            
            for (let i = 0; i < CONFIG.cantidadParticulas; i++) {
                const i3 = i * 3;
                vecOrigen.fromArray(posicionesOrigen, i3); 
                vecObjetivo.fromArray(siguientePosicionesObjetivo, i3);
                
                vecEnjambre.lerpVectors(vecOrigen, vecObjetivo, 0.5);
                
                const direccionDesplazamiento = vecTemp.set( 
                    ruido3D(i * 0.05, 10, 10), 
                    ruido3D(20, i * 0.05, 20), 
                    ruido3D(30, 30, i * 0.05) 
                ).normalize();
                
                const factorDistancia = vecOrigen.distanceTo(vecObjetivo) * 0.1 + cantidadDesplazamientoCentro;
                vecEnjambre.addScaledVector(direccionDesplazamiento, factorDistancia * (0.5 + Math.random() * 0.8));
                
                posicionesEnjambre[i3] = vecEnjambre.x; 
                posicionesEnjambre[i3 + 1] = vecEnjambre.y; 
                posicionesEnjambre[i3 + 2] = vecEnjambre.z;
            }
            
            indiceFormaActual = siguienteIndiceForma;
            estadoMorph.progreso = 0;
            
            if (lineaTiempoMorph) lineaTiempoMorph.pause();
            
            lineaTiempoMorph = anime({
                 targets: estadoMorph, 
                 progreso: 1, 
                 duration: CONFIG.duracionMorph, 
                 easing: 'cubicBezier(0.4, 0.0, 0.2, 1.0)',
                 complete: () => {
                     console.log("Morphing completado.");
                     document.getElementById('info').innerText = `Forma: ${FORMAS[indiceFormaActual].nombre} (Click para morph)`;
                     document.getElementById('info').style.textShadow = '0 0 5px rgba(0, 128, 255, 0.8)';
                     
                     posicionesActuales.set(posicionesObjetivo[indiceFormaActual]);
                     geometriaParticulas.attributes.position.needsUpdate = true;
                     
                     intensidadesEfectoParticulas.fill(0.0);
                     geometriaParticulas.attributes.aIntensidadEfecto.needsUpdate = true;
                     
                     posicionesOrigen.set(posicionesObjetivo[indiceFormaActual]);
                     actualizarColores();
                     
                     estaMorphing = false; 
                     controles.autoRotate = true;
                 }
            });
        }

        function animar() {
            requestAnimationFrame(animar);
            if (!estaInicializado) return;
            
            const tiempoTranscurrido = reloj.getElapsedTime();
            const deltaTiempo = reloj.getDelta();
            controles.update();
            
            const posiciones = geometriaParticulas.attributes.position.array;
            const intensidadesEfecto = geometriaParticulas.attributes.aIntensidadEfecto.array;

            if (estaMorphing) {
                actualizarAnimacionMorph(posiciones, intensidadesEfecto, tiempoTranscurrido, deltaTiempo);
            } else {
                actualizarAnimacionInactiva(posiciones, intensidadesEfecto, tiempoTranscurrido, deltaTiempo);
            }
            
            geometriaParticulas.attributes.position.needsUpdate = true;
            
            if (estaMorphing || geometriaParticulas.attributes.aIntensidadEfecto.needsUpdate) {
                 geometriaParticulas.attributes.aIntensidadEfecto.needsUpdate = true;
            }
            
            compositor.render(deltaTiempo);
        }

        function actualizarAnimacionMorph(posiciones, intensidadesEfecto, tiempoTranscurrido, deltaTiempo) {
            const t = estadoMorph.progreso;
            const objetivos = posicionesObjetivo[indiceFormaActual];
            const intensidadEfecto = Math.sin(t * Math.PI);
            const remolinoActual = intensidadEfecto * CONFIG.factorRemolino * deltaTiempo * 50;
            const ruidoActual = intensidadEfecto * CONFIG.intensidadMaximaRuido;

            for (let i = 0; i < CONFIG.cantidadParticulas; i++) {
                const i3 = i * 3;
                vecOrigen.fromArray(posicionesOrigen, i3);
                vecEnjambre.fromArray(posicionesEnjambre, i3);
                vecObjetivo.fromArray(objetivos, i3);

                const t_inv = 1.0 - t; 
                const t_inv_cuad = t_inv * t_inv; 
                const t_cuad = t * t;
                
                posBezier.copy(vecOrigen).multiplyScalar(t_inv_cuad);
                posBezier.addScaledVector(vecEnjambre, 2.0 * t_inv * t);
                posBezier.addScaledVector(vecObjetivo, t_cuad);

                if (remolinoActual > 0.01) {
                    vecTemp.subVectors(posBezier, vecOrigen);
                    ejeRemolino.set( 
                        ruido3D(i * 0.02, tiempoTranscurrido * 0.1, 0), 
                        ruido3D(0, i * 0.02, tiempoTranscurrido * 0.1 + 5), 
                        ruido3D(tiempoTranscurrido * 0.1 + 10, 0, i * 0.02) 
                    ).normalize();
                    
                    vecTemp.applyAxisAngle(ejeRemolino, remolinoActual * (0.5 + Math.random() * 0.5));
                    posBezier.copy(vecOrigen).add(vecTemp);
                }

                if (ruidoActual > 0.01) {
                    const tiempoRuido = tiempoTranscurrido * CONFIG.escalaTiempoRuido;
                    desplazamientoRuido.set( 
                        ruido4D(posBezier.x * CONFIG.frecuenciaRuido, posBezier.y * CONFIG.frecuenciaRuido, posBezier.z * CONFIG.frecuenciaRuido, tiempoRuido),
                        ruido4D(posBezier.x * CONFIG.frecuenciaRuido + 100, posBezier.y * CONFIG.frecuenciaRuido + 100, posBezier.z * CONFIG.frecuenciaRuido + 100, tiempoRuido),
                        ruido4D(posBezier.x * CONFIG.frecuenciaRuido + 200, posBezier.y * CONFIG.frecuenciaRuido + 200, posBezier.z * CONFIG.frecuenciaRuido + 200, tiempoRuido)
                    );
                    posBezier.addScaledVector(desplazamientoRuido, ruidoActual);
                }

                posiciones[i3] = posBezier.x;
                posiciones[i3 + 1] = posBezier.y;
                posiciones[i3 + 2] = posBezier.z;

                intensidadesEfecto[i] = intensidadEfecto;
            }
             
            geometriaParticulas.attributes.aIntensidadEfecto.needsUpdate = true;
        }

        function actualizarAnimacionInactiva(posiciones, intensidadesEfecto, tiempoTranscurrido, deltaTiempo) {
            const escalaRespirar = 1.0 + Math.sin(tiempoTranscurrido * 0.5) * 0.015;
            const tiempoEscalado = tiempoTranscurrido * CONFIG.velocidadFlujoInactivo;
            const frecuencia = 0.1;

            let necesitaReinicioIntensidadEfecto = false;

            for (let i = 0; i < CONFIG.cantidadParticulas; i++) {
                const i3 = i * 3;
                vecOrigen.fromArray(posicionesOrigen, i3);
                vecTemp.copy(vecOrigen).multiplyScalar(escalaRespirar);
                
                vecFlujo.set( 
                    ruido4D(vecTemp.x * frecuencia, vecTemp.y * frecuencia, vecTemp.z * frecuencia, tiempoEscalado),
                    ruido4D(vecTemp.x * frecuencia + 10, vecTemp.y * frecuencia + 10, vecTemp.z * frecuencia + 10, tiempoEscalado),
                    ruido4D(vecTemp.x * frecuencia + 20, vecTemp.y * frecuencia + 20, vecTemp.z * frecuencia + 20, tiempoEscalado)
                );
                
                vecTemp.addScaledVector(vecFlujo, CONFIG.intensidadFlujoInactivo);
                
                vecActual.fromArray(posiciones, i3);
                vecActual.lerp(vecTemp, 0.05);
                
                posiciones[i3] = vecActual.x;
                posiciones[i3 + 1] = vecActual.y;
                posiciones[i3 + 2] = vecActual.z;

                if (intensidadesEfecto[i] !== 0.0) {
                    intensidadesEfecto[i] = 0.0;
                    necesitaReinicioIntensidadEfecto = true;
                }
            }
             
            if (necesitaReinicioIntensidadEfecto) {
                 geometriaParticulas.attributes.aIntensidadEfecto.needsUpdate = true;
             }
        }

        function manejarClicLienzo(evento) {
            if (evento.target.closest('#controles')) { return; }
            activarMorph();
        }

        function manejarRedimensionamiento() {
            camara.aspect = window.innerWidth / window.innerHeight;
            camara.updateProjectionMatrix();
            renderizador.setSize(window.innerWidth, window.innerHeight);
            compositor.setSize(window.innerWidth, window.innerHeight);
        }

        // Iniciar la aplicación
        inicializar();
    </script>
</body>
</html>
